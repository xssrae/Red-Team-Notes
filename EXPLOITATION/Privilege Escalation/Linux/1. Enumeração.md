---
tags:
  - EXPLOITATION
  - Linux
---
A enumeração é a *primeira etapa* a ser executada quando você obtém acesso a qualquer sistema. Você pode ter acessado o sistema explorando uma vulnerabilidade crítica que resultou em acesso em nível de raiz ou apenas encontrou uma maneira de enviar comandos usando uma conta com poucos privilégios. Os trabalhos de teste de penetração, diferentemente das máquinas CTF, não terminam quando você obtém acesso a um sistema específico ou a um nível de privilégio de usuário. Como você verá, a enumeração é tão importante durante a fase pós-comprometimento quanto antes.

## `hostname`

O comando `hostname` retornará o nome do host do computador de destino. Embora esse valor possa ser facilmente alterado ou ter uma cadeia de caracteres relativamente sem sentido (por exemplo, Ubuntu-3487340239), em alguns casos, ele pode fornecer informações sobre a função do sistema de destino na rede corporativa (por exemplo, SQL-PROD-01 para um servidor SQL de produção).

# `uname -a`

Imprime as informações do sistema, fornecendo detalhes adicionais sobre o kernel usado pelo sistema. Isso será útil na busca de possíveis vulnerabilidades do kernel que possam levar ao aumento de privilégios

## `/proc/version`

O sistema de arquivos `proc` fornece informações sobre os processos do sistema de destino. Você encontrará o proc em muitos tipos diferentes de Linux, o que o torna uma ferramenta essencial para ter em seu arsenal.
A consulta a `/proc/version` pode fornecer informações sobre a versão do kernel e dados adicionais, como se um compilador (por exemplo, GCC) está instalado.

## `/etc/issue`

Os sistemas também podem ser identificados por meio do arquivo `/etc/issue`. Esse arquivo geralmente contém algumas informações sobre o sistema operacional, mas pode ser facilmente personalizado ou alterado. 

## `ps`

O comando `ps` mostrará os processos do shell atual.

A saída do ps (Status do processo) mostrará o seguinte;

- **PID**: O ID do processo (exclusivo do processo)
- **TTY**: Tipo de terminal usado pelo usuário
- **Time**: quantidade de tempo de CPU usada pelo processo (NÃO é o tempo em que o processo esteve em execução)
- **CMD**: O comando ou executável em execução (NÃO exibirá nenhum parâmetro da linha de comando)

O comando "ps" oferece algumas opções úteis.

- `ps -A`: exibe todos os processos em execução
- `ps axjf`: Exibir a árvore de processos (veja a formação da árvore até que o ps axjf seja executado abaixo)
![[Pasted image 20231218151356.png]]

- `ps aux`: a opção aux mostrará os processos de todos os usuários (a), exibirá o usuário que iniciou o processo (u) e mostrará os processos que não estão anexados a um terminal (x). 

## `env`

O comando `env` mostrará as variáveis ambientais.

![[Pasted image 20231218151459.png]]

A variável PATH pode ter um compilador ou uma linguagem de script (por exemplo, Python) que pode ser usada para executar código no sistema de destino ou ser aproveitada para o aumento de privilégios.

## `sudo -l`

O sistema de destino pode ser configurado para permitir que os usuários executem alguns (ou todos) comandos com privilégios de root. O comando `sudo -l` pode ser usado para listar todos os comandos que o usuário pode executar usando o sudo.

## `ls -la`

![[Pasted image 20231218151645.png]]

## `Id`

O comando `id` fornecerá uma visão geral do nível de privilégio dos usuários e das associações de grupo.

![[Pasted image 20231218153246.png]]

## `/etc/passwd`

A leitura do arquivo `/etc/passwd` pode ser uma maneira fácil de descobrir usuários no sistema.

![[Pasted image 20231218153345.png]]

Ele pode ser facilmente cortado e convertido em uma lista útil para ataques de força bruta.
![[Pasted image 20231218153536.png]]

Lembre-se de que isso retornará todos os usuários, alguns dos quais são usuários de sistema ou de serviço, o que não seria muito útil. Outra abordagem poderia ser usar o grep para "home", pois os usuários reais provavelmente terão suas pastas no diretório "home"

![[Pasted image 20231218153639.png]]

## `ifconfig`

O sistema de destino pode ser um *ponto de ligação com outra rede*. O comando `ifconfig` nos fornecerá informações sobre as interfaces de rede do sistema. O exemplo abaixo mostra que o sistema de destino tem três interfaces (eth0, tun0 e tun1). Nossa máquina atacante pode alcançar a interface eth0, mas não pode acessar diretamente as duas outras redes.

![[Pasted image 20231218154055.png]]

Isso pode ser confirmado usando o comando `ip route` para ver quais rotas de rede existem.

![[Pasted image 20231218154123.png]]

## `find`

A busca de informações importantes e possíveis vetores de escalonamento de privilégios no sistema de destino pode ser proveitosa. 

Veja a seguir alguns exemplos úteis do comando `find`.

Localizar arquivos:

- `find . -name flag1.txt`: localiza o arquivo chamado "flag1.txt" no diretório atual
- `find /home -name flag1.txt`: localiza os nomes dos arquivos "flag1.txt" no diretório /home
- `find / -type d -name config`: localiza o diretório chamado config em "/"
- `find / -type f -perm 0777`: localiza arquivos com as permissões 777 (arquivos que podem ser lidos, gravados e executados por todos os usuários)
- `find / -perm a=x`: localiza arquivos executáveis
- `find /home -user frank`: localiza todos os arquivos do usuário "frank" em "/home"
- `find / -mtime 10`: localiza arquivos que foram modificados nos últimos 10 dias
- `find / -atime 10`: localiza os arquivos que foram acessados nos últimos 10 dias
- `find / -cmin -60`: localiza os arquivos alterados na última hora (60 minutos)
- `find / -amin -60`: encontra arquivos acessados na última hora (60 minutos)
- `find / -size 50M`: localizar arquivos com tamanho de 50 MB

Esse comando também pode ser usado com os sinais (+) e (-) para especificar um arquivo que seja maior ou menor que o tamanho fornecido.

![[Pasted image 20231218154630.png]]

O exemplo acima retorna arquivos com mais de 100 MB. É importante observar que o comando tende a gerar erros que, às vezes, tornam a saída difícil de ler. Por isso, é aconselhável usar o comando `find -type f 2>/dev/null` para redirecionar os erros para `/dev/null` e obter uma saída mais limpa (abaixo).

![[Pasted image 20231218154818.png]]

Pastas e arquivos que podem ser gravados ou executados:

- `find / -writable -type d 2>/dev/null` : Localiza pastas que podem ser gravadas em todo o mundo
- `find / -perm -222 -type d 2>/dev/null`: Localizar pastas que podem ser gravadas em todo o mundo
- `find / -perm -o w -type d 2>/dev/null`: Encontrar pastas graváveis em todo o mundo

O motivo pelo qual vemos três comandos `find` diferentes que poderiam levar ao mesmo resultado pode ser visto no documento do manual. Como você pode ver abaixo, o parâmetro perm afeta a maneira como o `find` funciona.

![[Pasted image 20231218155934.png]]

- `find / -perm -o x -type d 2>/dev/null` : Localizar pastas executáveis em todo o mundo

Localizar ferramentas de desenvolvimento e linguagens compatíveis:

- `find / -name perl*`
- `find / -name python*`
-  `find / -name gcc*`

# Ferramentas de enumeração automatizadas

O ambiente do sistema de destino influenciará a ferramenta que você poderá usar. Por exemplo, você não poderá executar uma ferramenta escrita em Python se ela não estiver instalada no sistema de destino. É por isso que seria melhor estar familiarizado com algumas ferramentas em vez de ter uma única.

- LinPeas: https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS
- LinEnum: https://github.com/rebootuser/LinEnum
- LES (Linux Exploit Suggester): https://github.com/mzet-/linux-exploit-suggester
- Linux Smart Enumeration: https://github.com/diego-treitos/linux-smart-enumeration
- Linux Priv Checker: https://github.com/linted/linuxprivchecker